#+TITLE: Fonones y espectroscopía Raman en semiconductores bidimensionales.
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [12pt,a4paper]
#+LaTeX_HEADER:\usepackage[left=1cm,right=1cm,top=1.5cm, bottom=2cm]{geometry}
#+LaTeX_HEADER:\usepackage[utf8]{inputenc}
#+LaTeX_HEADER:\usepackage{siunitx}
#+LaTeX_HEADER:\usepackage{amsmath}
#+LaTeX_HEADER:\usepackage{adjustbox}
#+LaTeX_HEADER:\usepackage{tabularx}
#+LaTeX_HEADER:\usepackage{mathtools}
#+LaTeX_HEADER:\usepackage{booktabs} %Publication quality tables in LaTeX.
#+LaTeX_HEADER:\usepackage{pdflscape}
#+AUTHOR: Casimiro Victoria Castillo
#+latex_header:\usepackage[citestyle=authoryear-icomp,bibstyle=authoryear, hyperref=true,backref=true,maxcitenames=3,url=true,backend=biber,natbib=true] {biblatex}
#+latex_header:\addbibresource{TFG-Casimir.bib}



\begin{abstract}
Los materiales bidimensionales (2D) como el grafeno son de gran interés tanto por sus
propiedades físicas exclusivas como por sus aplicaciones potenciales. El estudio de la dinámica de la red cristalina (fonones) de estos materiales es un requisito previo para entender su estabilidad estructural y propiedades térmicas, así como sus propiedades de transporte y ópticas.


Este Trabajo de Fin de Grado consiste en la computación de los modos vibracionales de
materiales semiconductores 2D y su correlación con los observables relevantes para la interpretación de los experimentos de dispersión de luz.

\end{abstract}

\newpage


* TODO Introduccion

Por ahora solo algunas ideas que hay que desarrollar.

La idea que tengo es explicar el modelo de  Born y  Von karman (1921), tal y como viene explicado en cite:brueesch82_phonon, pagina 4.

Luego explicar que haciendo uso de la aproximación adiabática, podemos, siempre que sea válida tal aproximación -explicar cuando lo es y cuando deja de serlo-, considerar los nucleos ionicos y los elecrones de valencia como constituyentes independientes del sólido, de manera que podemos escribir la energía potencial (o el Hamiltoniano) como una suma de las distintas contribuciones, y que para 

Pasar a describir la aproximación armónica: escribir el potencial, las ecuaciones de movimiento de Lagrange, y pasar de estas ecuaciones de movimiento en el espacio de posiciones al problema de valores propios de la matriz dinámica en el espació de vectores de onda.

Una vez concluida la introducción teórica general, valida para cualquier cristal, escribir el potencial separando el "stretching" y "bendig¨ y escribir la matriz dinámica, teniendo en cuenta que debido a la simetria del cristal la matriz de constantes de fuerza (y su transformada de Fourier, la matriz dinámica), debe cumplir ciertas relaciones (forma de la matriz, elementos nulos, relación entre elementos, ...), cite:aizawa90_bond_soften_monol_graph_formed (en el apendice). Hay que hacer notar que para expresar la matriz de constantes de fuerza en coordenadas cartesianas hay que hacer el correspondiente cambio de coordenadas desde las radiales-transversales.


\normalcolor

Las vibraciones reticulares están regidas por las fuerzas que experimentan los átomos cuando se desplazan de su posición de equilibrio. La primera hipótesis es que cada átomo tiene una posicion de equilibrio en el cristal, y consideraremos que estos átomos vibran con una amplitud pequeña (en comparación con la distancia interatómica) alrededor de su posición de equilibrio, de manera que el sólido se encuentra en estados que corresponden a lo que macroscópicamente se conoce como /la región de comportamiento elástico lineal/, donde se verifica la ley de Hooke.

Podremos por tanto aproximar la energía potencial de interacción por el termino armónico de su desarrolo en serie de potencias del desplazamiento \color{red} desarollar como a partir de la energia potencial del cristal $\mathcal{U}$, usando una aproximacion armonica, obtenemos la ecuacion secular para los fonones.\normalcolor.

Un fonón es un modo de vibración cuantizado que tiene lugar en una red cristalina. El estudio de los fonones juega un papel muy importante en la física del estado sólido porque los fonones tienen una gran importancia en muchas propiedades físicas de los sólidos. Los fonones son una versión mecano-cuantica de los modos normales de vibración de la mecánica clasica, donde cada parte de la red oscila con la misma frecuencia. Estos modos normales son importantes porque cualquier movimiento vibracional de la red puede describirse como una superposición de modos normales de distinta frecuencia, en este sentido son la base de las vibraciones de la red.



** TODO Matriz dinámica 
 La matriz dinámica es una cantidad central en la dinámica reticular: las frecuencias de los fonones (vibraciones reticulares cuantificadas) se calculan a partir de los valores propios de la matriz dinámica:

\begin{equation}
\sum_{\alpha\prime}D_{\alpha\alpha\prime}\cdot\vec e_{\alpha\prime}(\vec q)=\omega^{2}\vec e_{\alpha}(\vec q)
\end{equation}   

Por lo tanto, las frecuencias $\omega$ como función de vector de ondas $\vec q$ del fonón son solución de la ecuación secular:

\begin{equation}
\det\left|\frac{1}{\sqrt{M_\alpha M_{\alpha\prime}}}D^{ij}_{\alpha\alpha\prime}\left(\vec q\right)-\omega^2\left(\vec q\right)\right| 
\end{equation}

donde $M_{\alpha}$ es la masa del átomo $\alpha$ y la matriz dinámica viene definida por:

\begin{equation}
D_{\alpha,\alpha\prime}^{i,j}=\frac{\partial^2 E}{\partial u_{\alpha}^{*i}(\vec q)\partial u_{\alpha\prime}^{j}(\vec q)}
\label{eq:Matriz_Dinámica}
\end{equation}

donde $u_{\alpha}^{i}$ representa el desplazamiento del átomo $\alpha$ en la dirección $i$.

La segunda derivada de la energía de la ecuación \ref{eq:Matriz_Dinámica} corresponde al cambio en la fuerza que actua sobre el átomo $\alpha\prime$ en la dirección $j$ cuando se desplaza el átomo $\alpha$ en la dirección $i$

\begin{equation}
D_{\alpha\alpha\prime}^{ij}(\vec q)=\frac{\partial}{\partial u^{*\alpha}_{i}}F^{j}_{\alpha\prime}(\vec q)
\end{equation}

   Puesto que el cálculo de los modos de vibración por primeros principios empieza por establecer la geometria del cristal en equilibrio, vamos a comprobar que con los datos proporcionados que el BN monolayer se trata  de un cristal bidimensional de base diatómica, cuya celda unidad viene dada por (datos proporcionados):

\begin{equation}
\vec a_1=a(1,0);\qquad\vec a_2=a\left(-\frac{1}{2},\frac{\sqrt{3}}{2}\right)
\end{equation}


#+begin_src python :session :results output  :exports results :async
  import numpy as np 
  from  numpy  import array, sqrt, sort, vdot, pi, arccos
  from numpy.linalg import norm
  import pandas as pd
  import matplotlib
  from matplotlib import pyplot as plt

  a=1 
  a_1=np.array([a,0])
  a_2=np.array([-a/2,sqrt(3)*a/2])
#+end_src

#+RESULTS:

Podemos comprobar que efectivamente se trata de una celdilla hexagonal, pues los dos vectores base forman un angulo de $\SI{2\pi/3}{\radian}$


Numeraremos las celdillas unidad con un índice vectorial $\vec l=\left( l_1, l_2\right)$, notemos que aunque es habitual representar la celdilla con un indice entero $n$ es más sencillo y facilita los cálculos (así como determinar a que celdilla no referimos) el uso de un índice vectorial. Las posiciones de los nudos son $\vec R_{\vec l}=l_1 \vec{a}_1 + l_2 \vec{a}_2$.

Visualizamos una región de la red hexagonal, con los correspondientes nudos (que no átomos), así como la correspondiente celda unidad,


#+begin_src python :session :results none :exports results :async
  def R_l(l_1,l_2):
   return l_1*a_1+l_2*a_2 

  reddenudos=array([R_l(l_1,l_2) for l_1 in range(-3, 4)
    for l_2 in range(-3,4)])

  x = reddenudos[:,0]
  y = reddenudos[:,1]
  plt.plot(x,y,"o")
  ax = plt.axes()
  ax.arrow(R_l(0,0)[0],R_l(0,0)[1],
	   R_l(1,0)[0],R_l(1,0)[1])
  ax.arrow(R_l(0,0)[0],R_l(0,0)[1],
	   R_l(0,1)[0],R_l(0,1)[1])
  plt.savefig("Graficas/Reddenudos.jpg")
  plt.close()
#+end_src

#+ATTR_ORG: :width 120
#+ATTR_LATEX: :width 5 cm 

[[file:Graficas/Reddenudos.jpg]]


/Hacer figuras de la red reciproca, primera zona de Brillouin (y puntos especiales, Gamma, K, K', M)./


\vspace{0.7cm}
Para calcular los modos de vibración por primeros principios debemos determinar primero las posiciones atómicas de equilibrio  en la celda unidad **nota: proporcionadas como datos**

Los átomos estan situados en:

\begin{equation}
\begin{aligned}
\vec R_B&=\frac{1}{3}\vec{a_1}+2\vec{a_2}\\
\vec R_N&=\frac{2}{3}\vec{a_1}+\frac{1}{3}\vec{a_2}
\end{aligned}
\end{equation}

#+begin_src python :session :results none :exports none :async
  R_B=1/3*a_1+2/3*a_2
  R_N=2/3*a_1+1/3*a_2
#+end_src

Las posiciones de equilibrio de los átomos de la base respecto de su nudo son $\vec{R}_\alpha^0$ , con $\alpha=1,2$, puesto que la base tiene 2 átomos, el $1$ hará referencia a los átomos de $B$ y $2$ a los de átomos de $N$ (notemos que aunque los átomos fuesen idénticos tendriamos que especificar a que átomo de la base nos referimos, puesto que no ocupan posiciones equivalentes).


Las posiciones de equilibrio de los átomos: $\vec R_{\alpha,\vec l}=\vec{R}_{\vec{l}} + \vec R_\alpha^0$  así como los desplazamientos atómicos: $\vec u_{\alpha,\vec l}$ quedarán por tanto identificados por medio de dos índices.

Pasamor ahora a representar la red de átomos:


#+begin_src python :session :results none :exports results :async
  #Posiciones de equilibrio de los átomos

  def R_alpha_l(alpha,l_1,l_2):
    if alpha == 1:
      return l_1*a_1+l_2*a_2+R_B

    elif alpha == 2:
      return l_1*a_1+l_2*a_2+R_N

    else:
      print("Error, alpha solo puede ser 1 o 2 ")

  AtomosB=array([R_alpha_l(1,l_1,l_2) for l_1 in range(-4, 5)
		 for l_2 in range(-4,5)])

  AtomosN=array([R_alpha_l(2,l_1,l_2) for l_1 in range(-4, 5)
		 for l_2 in range(-4,5)])

  xB = AtomosB[:,0]
  yB = AtomosB[:,1]
  plt.plot(xB,yB,"o",color="red")

  xN = AtomosN[:,0]
  yN = AtomosN[:,1]
  plt.plot(xN,yN,"o",color="blue")

  plt.savefig("Graficas/Reddeatomos.jpg")
  plt.close()
#+end_src

#+RESULTS:


#+ATTR_ORG: :width 480
#+ATTR_LATEX: :width 8 cm 
[[file:Graficas/Reddeatomos.jpg]]

Las dimensiones del cristal son $L_1=N_1 a_1$ y $L_2=N_2 a_2$, donde $N_i$ ($i=1,2$) es el número de celdillas en la dirección $\vec a_i$. El cristal tiene tiene $N=N_1N_2$ celdillas unidad primitivas y $2N$ átomos.


*La idea básica es que si la base tiene $r$ átomos entonces debemos plantear y resolver las ecuaciones de movimiento de los $r$ átomos de la base de la celdilla $\vec 0$*, por lo tanto en el caso que estamos estudiando debemos resolver 2 ecuaciones vectoriales de movimiento: una para el átomo de $B$ y la otra para el de $N$.

/Falta reescribir completamente y ampliar mucho la introducción teórica/


Notar que aunque el cristal sea bi-dimensional, los átomos de este pueden vibrar en las 3 direcciones espaciales.

/Explicar que podemos tratar por un lado las vibraciones en el plano del cristal y por otro las vibraciones perpendiculares a este, ya que se trata de vibraciones completamente desacopladas./

Que la  ecuación secular tiene $3 N_\nu=6$ soluciones que describen las $6$ ramas de la relación de dispersión, es decir, las $6$ frecuencias características de los $6$ modos normales de vibración de vector de onda $\vec q$. Se cumple que el número total de modos normales de vibración coincide con el triple del número total de átomos, es decir, \textit{con el de grados de libertad de movimiento de los átomos}

Debemos hacer notar que /como la energía potencial es una función cuadrática de los desplazamientos atómicos $u^B_i(\vec R_{\vec l})$ $u^N_i(\vec R_{\vec l})$ la matriz de constantes de fuerza tiene la forma $\phi_{ij}^{BN}(\vec R_{\vec l})=\phi_{ji}^{NB}(-\vec R_{\vec l})$, y su transformada de Fourier, es decir, la matriz dinámica, es una matriz Hermítica/ (cite:falkovsky08_symmet_const_phonon_disper_graph), 



\newpage
* TODO Desarrollo del trabajo

** Clasificación de los vecinos  :noexport:


Puesto que debemos determinar cuales son las posiciones de equilibrio de los átomos más cercanos a los átomos de la celda $\vec 0$ antes que nada genero un array con los datos que voy a necesitar, ordenando las filas de manera creciente a la distancia a cada uno de los 2 átomos de la celda  $l=\vec 0$ hasta los cuartos vecinos, y guardando el array con la información como un DataFrame de pandas, que facilita mucho la manipulación de los datos.



#+begin_src python :session :results latex :exports results :async
  from sympy import *
  import pandas as pd

  ## Parametros de la red, de la celdilla y del cristal
  a=Symbol('a', real=True, positive=True)
  q_x=Symbol('q_x', real=True);  q_y=Symbol('q_y', real=True)
  q=Matrix([q_x,q_y])
  a_1=Matrix([a,0]); a_2=Rational(1,2)*Matrix([-a,sqrt(3)*a])
  R_B=Rational(1,3)*a_1+Rational(2,3)*a_2; R_N=Rational(2,3)*a_1+Rational(1,3)*a_2

  ## Masas de los átomos, frecuencia, ...
  M_B, M_N, omega=symbols("M_B, M_N, omega") #masa de los átomos de Boro y N.
  def masa(alpha):
    if alpha == 1:
      return M_B

    elif alpha == 2:
      return M_N

    else:
      print("Error, alpha sólo puede se 1 o 2")


  ## Vector R_l (vector de traslación primitivo)
  def R_l(l_1,l_2):
    return l_1*a_1+l_2*a_2

  ## Vector de posición de los átomos del cristal (en equilibrio)
  def R_alpha_l(alpha,l_1,l_2):
    if alpha == 1:
      return l_1*a_1+l_2*a_2+R_B

    elif alpha == 2:
      return l_1*a_1+l_2*a_2+R_N

    else:
      print("Error, alpha solo puede ser 1 o 2 ")

  ## Vector unitario que une uno de los átomos en la celdilla 0 con el átomo considerado
  def R_hat(alphaprima,alpha,l_1,l_2):
    if (R_alpha_l(alpha,l_1,l_2)-R_alpha_l(alphaprima,0,0)).norm()>0:
      return (R_alpha_l(alpha,l_1,l_2)-R_alpha_l(alphaprima,0,0))/(R_alpha_l(alpha,l_1,l_2)
						       -R_alpha_l(alphaprima,0,0)).norm()

    else:
      return (R_alpha_l(alpha,l_1,l_2)-R_alpha_l(alphaprima,0,0))

  def fase(l_1,l_2):
    return exp(I*q.dot(R_l(l_1,l_2)))

  ## Finalmente construyo un DataFrame de pandas con la información necesaria para
  ## identificar a los primeros, segundos, ... vecinos, según su distancia a cada uno
  ## de los átomos de la celdilla unidad
  def propiedades_atomos(l_1, l_2):
    return [(k, m, i, j,  R_hat(k,m,i,j),fase(i,j), (R_alpha_l(m,i,j)-R_alpha_l(k,0,0)).norm()/a)
	for k in [1,2] for m in [1,2]  for i in range(-l_1,l_1+1) for j in range(-l_2,l_2+1)]

  columnas = [r"$\alpha\prime$",r"$\alpha$",r"$l_1$", r"$l_2$",r"$\hat R_{\nu\prime,\nu,\vec l}$",
   'Fase','Distancia']

  def Atomos(l_1, l_2):
    return pd.DataFrame(propiedades_atomos(l_1,l_2),columns=columnas).sort_values(
	 ['Distancia',r"$\alpha\prime$"], ascending=[True, True])
  ## Mostramos el dataframe como una tabla en formato \LaTeX.
  Atomos(2,2).head(26).to_latex(escape=False,float_format="{:0.4f}".format,index=False)
#+end_src      

#+RESULTS:
#+begin_export latex
\begin{tabular}{rrrrlll}
\toprule
 $\alpha\prime$ &  $\alpha$ &  $l_1$ &  $l_2$ & $\hat R_{\nu\prime,\nu,\vec l}$ &                                   Fase &    Distancia \\
\midrule
              1 &         1 &      0 &      0 &                          [0, 0] &                                      1 &            0 \\
              2 &         2 &      0 &      0 &                          [0, 0] &                                      1 &            0 \\
              1 &         2 &     -1 &      0 &              [-sqrt(3)/2, -1/2] &                          exp(-I*a*q_x) &    sqrt(3)/3 \\
              1 &         2 &      0 &      0 &               [sqrt(3)/2, -1/2] &                                      1 &    sqrt(3)/3 \\
              1 &         2 &      0 &      1 &                          [0, 1] &    exp(I*(-a*q_x/2 + sqrt(3)*a*q_y/2)) &    sqrt(3)/3 \\
              2 &         1 &      0 &     -1 &                         [0, -1] &     exp(I*(a*q_x/2 - sqrt(3)*a*q_y/2)) &    sqrt(3)/3 \\
              2 &         1 &      0 &      0 &               [-sqrt(3)/2, 1/2] &                                      1 &    sqrt(3)/3 \\
              2 &         1 &      1 &      0 &                [sqrt(3)/2, 1/2] &                           exp(I*a*q_x) &    sqrt(3)/3 \\
              1 &         1 &     -1 &     -1 &              [-1/2, -sqrt(3)/2] &    exp(I*(-a*q_x/2 - sqrt(3)*a*q_y/2)) &            1 \\
              1 &         1 &     -1 &      0 &                         [-1, 0] &                          exp(-I*a*q_x) &            1 \\
              1 &         1 &      0 &     -1 &               [1/2, -sqrt(3)/2] &     exp(I*(a*q_x/2 - sqrt(3)*a*q_y/2)) &            1 \\
              1 &         1 &      0 &      1 &               [-1/2, sqrt(3)/2] &    exp(I*(-a*q_x/2 + sqrt(3)*a*q_y/2)) &            1 \\
              1 &         1 &      1 &      0 &                          [1, 0] &                           exp(I*a*q_x) &            1 \\
              1 &         1 &      1 &      1 &                [1/2, sqrt(3)/2] &     exp(I*(a*q_x/2 + sqrt(3)*a*q_y/2)) &            1 \\
              2 &         2 &     -1 &     -1 &              [-1/2, -sqrt(3)/2] &    exp(I*(-a*q_x/2 - sqrt(3)*a*q_y/2)) &            1 \\
              2 &         2 &     -1 &      0 &                         [-1, 0] &                          exp(-I*a*q_x) &            1 \\
              2 &         2 &      0 &     -1 &               [1/2, -sqrt(3)/2] &     exp(I*(a*q_x/2 - sqrt(3)*a*q_y/2)) &            1 \\
              2 &         2 &      0 &      1 &               [-1/2, sqrt(3)/2] &    exp(I*(-a*q_x/2 + sqrt(3)*a*q_y/2)) &            1 \\
              2 &         2 &      1 &      0 &                          [1, 0] &                           exp(I*a*q_x) &            1 \\
              2 &         2 &      1 &      1 &                [1/2, sqrt(3)/2] &     exp(I*(a*q_x/2 + sqrt(3)*a*q_y/2)) &            1 \\
              1 &         2 &     -1 &     -1 &                         [0, -1] &    exp(I*(-a*q_x/2 - sqrt(3)*a*q_y/2)) &  2*sqrt(3)/3 \\
              1 &         2 &     -1 &      1 &               [-sqrt(3)/2, 1/2] &  exp(I*(-3*a*q_x/2 + sqrt(3)*a*q_y/2)) &  2*sqrt(3)/3 \\
              1 &         2 &      1 &      1 &                [sqrt(3)/2, 1/2] &     exp(I*(a*q_x/2 + sqrt(3)*a*q_y/2)) &  2*sqrt(3)/3 \\
              2 &         1 &     -1 &     -1 &              [-sqrt(3)/2, -1/2] &    exp(I*(-a*q_x/2 - sqrt(3)*a*q_y/2)) &  2*sqrt(3)/3 \\
              2 &         1 &      1 &     -1 &               [sqrt(3)/2, -1/2] &   exp(I*(3*a*q_x/2 - sqrt(3)*a*q_y/2)) &  2*sqrt(3)/3 \\
              2 &         1 &      1 &      1 &                          [0, 1] &     exp(I*(a*q_x/2 + sqrt(3)*a*q_y/2)) &  2*sqrt(3)/3 \\
\bottomrule
\end{tabular}
#+end_export


\newpage

** Matriz de constantes de fuerza y matriz dinámica
   Debemos construir la matriz dinámica, ya que sus valores propios nos dan $\omega^2$, siendo $\omega$ la frecuencia de propagación de cada uno de los modos.

Para ello necesitamos calcular las posiciones de equilibrio de los átomos de la red e identificar los primeros, segundos, terceros, ... vecinos. Una vez obtenidas las posiciones de los átomos y clasificados como prieros, segundos, ... vecinos segun la distancia al respectivo átomo de la celdilla $\vec 0$, procedemos a calcular la contribución a la matriz dinámica de cada uno de los átomos, para lo cual, necesitamos conocer la matriz de constantes de fuerza que corresponde a la interacción de cada átomo de la celdilla unidad con su n-esimo vecino.

Vamos a suponer (por simplificar) que un desplazamiento longitudinal (radial, que estará contenido en el plano del cristal) o transversal (tangencial, sea en el plano o perpendicular al plano) solo genera una fuerza radial o transversal.

Dibujar un esquema tipo
#+ATTR_ORG: :width 480
#+ATTR_LATEX: :width 8 cm 
[[file:Graficas/Esquema_Matriz_Constantes_de_fuerza.png]]
\normalcolor
*** Primeros vecinos
Para hacer más explicito el método seguido se muestra cómo se ha construido la contribución a la matriz dinámica para los primeros vecinos del átomo de boro de la celdilla $\vec l=\vec 0$.

\vspace{0.7cm} 
/Dibujar el boro, y sus vecinos/


#+begin_src python :session :results latex :exports none :async
  PrimerosVecinosBoro= Atomos(1,1)[(Atomos(1,1)['Distancia']<0.9) &\
  (Atomos(1,1)['Distancia']>0) & (Atomos(1,1)[r"$\alpha\prime$"]==1)]
  PrimerosVecinosBoro.to_latex(escape=False)
#+end_src

#+RESULTS:
#+begin_export latex
\begin{tabular}{lrrrrlll}
\toprule
{} &  $\alpha\prime$ &  $\alpha$ &  $l_1$ &  $l_2$ & $\hat R_{\nu\prime,\nu,\vec l}$ &                                 Fase &  Distancia \\
\midrule
10 &               1 &         2 &     -1 &      0 &              [-sqrt(3)/2, -1/2] &                        exp(-I*a*q_x) &  sqrt(3)/3 \\
13 &               1 &         2 &      0 &      0 &               [sqrt(3)/2, -1/2] &                                    1 &  sqrt(3)/3 \\
14 &               1 &         2 &      0 &      1 &                          [0, 1] &  exp(I*(-a*q_x/2 + sqrt(3)*a*q_y/2)) &  sqrt(3)/3 \\
\bottomrule
\end{tabular}
#+end_export

Podemos observar que para el átomo de nitrogeno de la celdilla $\vec l = (0,1)$ la correspondiente matriz de constantes de fuerza puede escribirse (en coordenadas cartesianas) como:

#+begin_src python :session :results none :exports none :async
  phi_1r__BN,phi_1ti__BN,phi_1to__BN=symbols('phi_1r__BN,phi_1ti__BN,phi_1to__BN')
  
  Phi_10__BN=Matrix([[phi_1ti__BN,0,0],[0,phi_1r__BN,0],[0,0,phi_1to__BN]])
  print(r"\begin{equation}\Phi_1^{BN}(0,1)=", latex(Phi_10__BN),r"\end{equation}")
#+end_src

#+RESULTS:
\begin{equation}\Phi_1^{BN}(0,1)= \left[\begin{matrix}\phi^{BN}_{1ti} & 0 & 0\\0 & \phi^{BN}_{1r} & 0\\0 & 0 & \phi^{BN}_{1to}\end{matrix}\right] \end{equation}
\vspace{0.7cm}



donde $\phi_r$ hace referencia a la constante de fuerza en la dirección radial (/bond stretching/) y $\phi_{ti}$ y $\phi_{to}$ a las constantes de fuerza en dirección tangencial (/bond bending/) dentro y fuera de plano, respectivamente.

Puesto que los otros dos primeros vecinos del boro son átomos exactamente iguales que este, y se encuentran a la misma distancia, podemos calcular sus respectivas matrices de fuerza simplemente rotando esta matriz:
\begin{equation}
\label{eq:2}
\Phi(\vec R_{\vec l})=U(\theta)^{-1}\Phi^{BN}_{1}(0,1)U(\theta)
\end{equation}

Donde $U(\theta)$ es la matriz de rotación, entorno al eje $\hat z$, para llevar el átomo de nitrogeno que esta en la celdilla $\vec l=(0, 1)$ a la posición que ocupan cada uno de los otros primeros vecinos en sus respectivas celdillas.

Por lo tanto tenemos que para el átomo situado en $\vec l=(-1,0)$
#+begin_src python :session :results none :exports none :async
  def U(theta):
    return Matrix([[cos(theta),sin(theta),0], [-sin(theta), cos(theta),0],[0,0,1]])
  
  # Para el átomo que ocupa la posición l_1=-1,0
  def Phi_1l__BN(theta):
    return U(-theta)*Phi_10__BN*U(theta)
 
  print_latex(Matrix([Phi_1l__BN(2*pi/3)[i,j].factor() for j in range(3) \
  for i in range(3)]).reshape(3,3))
#+end_src

\begin{equation}
\label{eq:3}
\left[\begin{matrix}\frac{3 \phi^{BN}_{1r} + \phi^{BN}_{1ti}}{4} & \frac{\sqrt{3} \left(\phi^{BN}_{1r} - \phi^{BN}_{1ti}\right)}{4} & 0\\\frac{\sqrt{3} \left(\phi^{BN}_{1r} - \phi^{BN}_{1ti}\right)}{4} & \frac{\phi^{BN}_{1r} + 3 \phi^{BN}_{1ti}}{4} & 0\\0 & 0 & \phi^{BN}_{1to}\end{matrix}\right]
\end{equation}

Y para el átomo situado en $\vec l= (0,0)$ la matriz de constantes de fuerza es:

#+begin_src python :session :results none :exports none :async
  print_latex(Matrix([Phi_1l__BN(-2*pi/3)[i,j].factor() for j in range(3) \
  for i in range(3)]).reshape(3,3))
#+end_src

\begin{equation}
\left[\begin{matrix}\frac{3 \phi^{BN}_{1r} + \phi^{BN}_{1ti}}{4} & - \frac{\sqrt{3} \left(\phi^{BN}_{1r} - \phi^{BN}_{1ti}\right)}{4} & 0\\- \frac{\sqrt{3} \left(\phi^{BN}_{1r} - \phi^{BN}_{1ti}\right)}{4} & \frac{\phi^{BN}_{1r} + 3 \phi^{BN}_{1ti}}{4} & 0\\0 & 0 & \phi^{BN}_{1to}\end{matrix}\right]
\end{equation}

Debemos notar, que tal y cómo hemos construido la matriz de constantes de fuerza, las vibraciones fuera del plano del cristal, en la dirección $z$, no estan acopladas a las interplanares, y tanto para realizar los cálculos cómo para mostrar las contibuciones las consideramos independientes, de manera que la contribución a matriz dinámica que tenemos por parte de la interacción de estos primeros vecinos teniendo en cuenta las vibraciones en el plano es:


#+begin_src python :session :results none :exports none :async
  D_1__BN=1/sqrt(M_B*M_N)*(Phi_10__BN*fase(0,1)+Phi_1l__BN(2*pi/3)*fase(-1,0) \
  +Phi_1l__BN(-2*pi/3)*fase(0,0))
  D_1__BN_xy=Matrix([D_1__BN[i,j].factor().simplify() for i in range(2) \
  for j in range(2)]).reshape(2,2)
  D_1__BN_zz=D_1__BN[2,2]
#+end_src

\begin{equation}
\left[\begin{smallmatrix}\frac{\left(3 \phi^{BN}_{1r} e^{i a q_{x}} + 3 \phi^{BN}_{1r} + \phi^{BN}_{1ti} e^{i a q_{x}} + 4 \phi^{BN}_{1ti} e^{\frac{i a \left(q_{x} + \sqrt{3} q_{y}\right)}{2}} + \phi^{BN}_{1ti}\right) e^{- i a q_{x}}}{4 \sqrt{M_{B} M_{N}}} & \frac{\sqrt{3} \left(1 - e^{i a q_{x}}\right) \left(\phi^{BN}_{1r} - \phi^{BN}_{1ti}\right) e^{- i a q_{x}}}{4 \sqrt{M_{B} M_{N}}}\\\frac{\sqrt{3} \left(1 - e^{i a q_{x}}\right) \left(\phi^{BN}_{1r} - \phi^{BN}_{1ti}\right) e^{- i a q_{x}}}{4 \sqrt{M_{B} M_{N}}} & \frac{\left(\phi^{BN}_{1r} e^{i a q_{x}} + 4 \phi^{BN}_{1r} e^{\frac{i a \left(q_{x} + \sqrt{3} q_{y}\right)}{2}} + \phi^{BN}_{1r} + 3 \phi^{BN}_{1ti} e^{i a q_{x}} + 3 \phi^{BN}_{1ti}\right) e^{- i a q_{x}}}{4 \sqrt{M_{B} M_{N}}}\end{smallmatrix}\right]
\label{eq:1}

\end{equation}


Mientras que la única componente no nula de la fila y columna 3 de esta matriz dinámica (la componente $zz$) es:
\begin{equation}
\label{eq:5}
\frac{\phi^{BN}_{1to} e^{i \left(- \frac{a q_{x}}{2} + \frac{\sqrt{3} a q_{y}}{2}\right)} + \phi^{BN}_{1to} + \phi^{BN}_{1to} e^{- i a q_{x}}}{\sqrt{M_{B} M_{N}}}
\end{equation}


De manera análoga, para los primeros vecinos del átomo de nitrogeno:

#+begin_src python :session :results latex :exports none :async
  PrimerosVecinosNitrogeno= Atomos(1,1)[(Atomos(1,1)['Distancia']<0.9) & \
  (Atomos(1,1)['Distancia']>0) & (Atomos(1,1)[r"$\alpha\prime$"]==2)]
  PrimerosVecinosNitrogeno.to_latex(escape=False)
#+end_src

#+RESULTS:
#+begin_export latex
\begin{tabular}{lrrrrlll}
\toprule
{} &  $\alpha\prime$ &  $\alpha$ &  $l_1$ &  $l_2$ & $\hat R_{\nu\prime,\nu,\vec l}$ &                                Fase &  Distancia \\
\midrule
21 &               2 &         1 &      0 &     -1 &                         [0, -1] &  exp(I*(a*q_x/2 - sqrt(3)*a*q_y/2)) &  sqrt(3)/3 \\
22 &               2 &         1 &      0 &      0 &               [-sqrt(3)/2, 1/2] &                                   1 &  sqrt(3)/3 \\
25 &               2 &         1 &      1 &      0 &                [sqrt(3)/2, 1/2] &                        exp(I*a*q_x) &  sqrt(3)/3 \\
\bottomrule
\end{tabular}
#+end_export


Por simetría, la matriz de constantes de fuerza para la interacción entre el átomo de nitrogeno y su primer vecino situado en $\vec l= (0,-1)$ es igual a la que hemos visto antes para el átomo de boro y su primer vecino (un átomo de nitrogeno) en la celdilla $\vec l= (0,1)$:

Y por lo tanto, la contribución a matriz dinámica que tenemos por parte de la interacción de estos primeros vecinos es:

#+begin_src python :session :results none :exports none :async
  Phi_10__NB=Phi_10__BN
  def Phi_1l__NB(theta):
    return U(-theta)*Phi_10__NB*U(theta)
 
  D_1__NB=1/sqrt(M_N*M_B)*(Phi_10__NB*fase(0,-1)+Phi_1l__NB(2*pi/3)*fase(1,0) \
  +Phi_1l__NB(-2*pi/3)*fase(0,0))
  D_1__NB_xy=(Matrix([D_1__NB[i,j].factor() for i in range(2) \
  for j in range(2)]).reshape(2,2))
  D_1__NB_zz=D_1__NB[2,2]
#+end_src

La parte que da la interacción dentro del plano:

\begin{equation}
\label{eq:10}
\left[\begin{matrix}\frac{3 \phi^{BN}_{1r} e^{i a q_{x}} + 3 \phi^{BN}_{1r} + 4 \phi^{BN}_{1ti} e^{\frac{i a q_{x}}{2}} e^{- \frac{\sqrt{3} i a q_{y}}{2}} + \phi^{BN}_{1ti} e^{i a q_{x}} + \phi^{BN}_{1ti}}{4 \sqrt{M_{B} M_{N}}} & \frac{\sqrt{3} \left(\phi^{BN}_{1r} - \phi^{BN}_{1ti}\right) \left(e^{i a q_{x}} - 1\right)}{4 \sqrt{M_{B} M_{N}}}\\\frac{\sqrt{3} \left(\phi^{BN}_{1r} - \phi^{BN}_{1ti}\right) \left(e^{i a q_{x}} - 1\right)}{4 \sqrt{M_{B} M_{N}}} & \frac{4 \phi^{BN}_{1r} e^{\frac{i a q_{x}}{2}} e^{- \frac{\sqrt{3} i a q_{y}}{2}} + \phi^{BN}_{1r} e^{i a q_{x}} + \phi^{BN}_{1r} + 3 \phi^{BN}_{1ti} e^{i a q_{x}} + 3 \phi^{BN}_{1ti}}{4 \sqrt{M_{B} M_{N}}}\end{matrix}\right]
\end{equation}

Mientras que la interacción fuera de plano viene dada por el elemento de matriz:

\begin{equation}
\label{eq:4}
\frac{\phi^{BN}_{1to} e^{i \left(\frac{a q_{x}}{2} - \frac{\sqrt{3} a q_{y}}{2}\right)} + \phi^{BN}_{1to} e^{i a q_{x}} + \phi^{BN}_{1to}}{\sqrt{M_{B} M_{N}}}
\end{equation}


\newpage
\eject \pdfpagewidth=210mm \pdfpageheight=297mm

*** Segundos vecinos y terceros vecinos

Pasamos a calcular las contribuciones a la matriz dinámica de los segundos y terceros vecinos.

#+begin_src python :session :results none :exports none
  SegundosVecinosBoro= Atomos(1,1)[(Atomos(1,1)['Distancia']<1.1) &\
  (Atomos(1,1)['Distancia']>0.9) & (Atomos(1,1)[r"$\alpha\prime$"]==1)]
  ##SegundosVecinosBoro.to_latex(escape=False)
#+end_src

#+RESULTS:

Tenemos $6$ segundos vecinos para cada uno de los dos átomos de la celdilla unidad y en este caso las interacciones son entre el mismo tipo de átomo. Fijandonos en el átomo de boro situado en la celdilla $\vec l=(1,0)$ podemos escribir la matriz de constantes de fuerza como:

\begin{equation}
\Phi_{2}^{BB}(1,0)=\begin{pmatrix}
\phi_{2r}^{(BB)} & 0 & 0 \\
0 & \phi_{2ti}^{(BB)} & 0 \\
 0 & 0  & \phi_{2to}^{(BB)}
\end{pmatrix}
\end{equation} 
 
mientras que para el atómo de nitrógeno la matriz de constantes de fuerza para el átomo situado en la celdilla $\vec l =(1,0)$ es:

\begin{equation}
\Phi_{2}^{NN}(1,0)=\begin{pmatrix}
\phi_{2r}^{(NN)} & 0 & 0 \\
0 & \phi_{2ti}^{(NN)} & 0 \\
 0 & 0  & \phi_{2to}^{(NN)}
\end{pmatrix}
\end{equation} 

y por tanto, la contribución a la matriz dinámica debida a estas interacciones será:

#+begin_src python :session :results none :exports both
  phi_2r__BB,phi_2ti__BB,phi_2to__BB=symbols('phi_2r__BB,phi_2ti__BB,phi_2to__BB')
  # Para el átomo que ocupa la posición l=1,0
  Phi_20__BB=Matrix([[phi_2ti__BB,0,0],[0,phi_2r__BB,0],[0,0,phi_2to__BB]])
  def Phi_2l__BB(theta):
    return U(-theta)*Phi_20__BB*U(theta)

  D_2__BB=1/M_B*(Phi_20__BB*fase(1,0)+Phi_2l__BB(pi/3)*fase(1,1)+ \
  Phi_2l__BB(-pi/3)*fase(0,-1)+ Phi_2l__BB(pi)*fase(-1,0)+ \
  Phi_2l__BB(2*pi/3)*fase(0,1)+Phi_2l__BB(-2*pi/3)*fase(-1,-1))

  #Phi_2_BB=Matrix([Phi_2__BB[i,j].rewrite(cos).simplify() for i in range(3) \
  # for j in range(3)]).reshape(3,3)
  SegundosVecinosNitrogeno= Atomos(1,1)[(Atomos(1,1)['Distancia']<1.1) &\
  (Atomos(1,1)['Distancia']>0.9) & (Atomos(1,1)[r"$\alpha\prime$"]==2)]
  #SegundosVecinosNitrogeno.to_latex(escape=False)
  phi_2r__NN,phi_2ti__NN,phi_2to__NN=symbols('phi_2r__NN,phi_2ti__NN,phi_2to__NN')
  Phi_20__NN=Matrix([[phi_2ti__NN,0,0],[0,phi_2r__NN,0],[0,0,phi_2to__NN]])
  # Para el átomo que ocupa la posición l=1,0
  def Phi_2l__NN(theta):
    return U(-theta)*Phi_20__NN*U(theta)
 
  D_2__NN=1/M_N*(Phi_20__NN*fase(1,0)+Phi_2l__NN(pi/3)*fase(1,1)+ \
  Phi_2l__NN(-pi/3)*fase(0,-1) +Phi_2l__NN(pi)*fase(-1,0)+Phi_2l__NN(2*pi/3)*fase(0,1) \
  +Phi_2l__NN(-2*pi/3)*fase(-1,-1))
  #Phi_2__NN=Matrix([Phi_2__NN[i,j].rewrite(cos).simplify() for i in range(3)\
  # for j in range(3)]).reshape(3,3)

#+end_src

\newpage

Mientras que para los terceros vecinos:
#+begin_src python :session :results output :exports both
  TercerosVecinosBoro= Atomos(1,1)[(Atomos(1,1)['Distancia']<sqrt(21)/3) &\
  (Atomos(1,1)['Distancia']>1) & (Atomos(1,1)[r"$\alpha\prime$"]==1)]
  
  TercerosVecinosNitrogeno= Atomos(1,1)[(Atomos(1,1)['Distancia']<sqrt(21)/3) &\
  (Atomos(1,1)['Distancia']>1) & (Atomos(1,1)[r"$\alpha\prime$"]==2)]
  
  phi_3r__BN,phi_3ti__BN,phi_3to__BN=symbols('phi_3r__BN,phi_3ti__BN,phi_3to__BN')
  phi_3r__NB,phi_3ti__NB,phi_3to__NB=symbols('phi_3r__BN,phi_3ti__BN,phi_3to__BN')
  
  # Para el átomo de N de la celdilla l=-1,-1  
  Phi_30__BN=Matrix([[phi_3ti__BN,0,0],[0,phi_3r__BN,0],[0,0,phi_3to__BN]])
  # Para el átomo de B de la celdilla l=1,1
  Phi_30__NB=Matrix([[phi_3ti__NB,0,0],[0,phi_3r__NB,0],[0,0,phi_3to__NB]])
  def Phi_3l__BN(theta):
    return U(-theta)*Phi_30__BN*U(theta)
 
  def Phi_3l__NB(theta):
    return U(-theta)*Phi_30__NB*U(theta)
 
  D_3__BN=1/sqrt(M_B*M_N)*(Phi_30__BN*fase(-1,-1)+Phi_3l__BN(2*pi/3)*fase(1,1) \
  +Phi_3l__BN(-2*pi/3)*fase(-1,1))
  #Phi_3__BN=Matrix([Phi_3__BN[i,j].rewrite(cos).simplify() for i in range(3) \
  #for j in range(3)]).reshape(3,3)
  D_3__NB=1/sqrt(M_N*M_B)*(Phi_30__NB*fase(1,1)+Phi_3l__NB(2*pi/3)*fase(-1,-1) \
  +Phi_3l__NB(-2*pi/3)*fase(1,-1))
  #print_latex(Phi_3__NB)
  #Phi_3__NB=Matrix([Phi_3__NB[i,j].rewrite(cos).simplify() for i in range(3) for j in range(3)]).reshape(3,3)
#+end_src

#+RESULTS:

Debemos tener en cuenta en este punto que las  constantes de fuerza de fuerza asociadas a la interaccion de un átomo \color{red}??consigo mismo o con la totalidad del cristal?? \normalcolor las excluimos con la ayuda de las condiciones impuestas por la invarianza respecto a la traslacion del cistal en su totalidad en las direcciones $x/z$ (cite:falkovsky08_symmet_const_phonon_disper_graph).


*** Matriz dinámica del cristal de BN (hasta terceros vecinos)
**** Empezamos por los primeros vecinos.
#+begin_src python :session :results latex :exports both
  #Dsup=D_2__BB.col_insert(3,D_1__BN+D_3__BN);
  #Dinf=(D_1__NB+D_3__NB).col_insert(3,D_2__NN)
  Dsup=zeros(3).col_insert(3,D_1__BN);
  Dinf=D_1__NB.col_insert(3,zeros(3))
  D=Dsup.row_insert(3,Dinf)
  def Matriu_com_a_Taula(Matriu,m,n):
    s = r"\begin{tabular}{|c|c|c|}\hline"
    s += r"$i$ & $j$ & $D_{i,j}$ \\ \hline"
    for i in range(m):
      for j in range(n):
	s += " $ %d $ & $ %d $ & $ %s $" %(i+1, j+1, latex(Matriu[i,j]))
	s += r"\\ \hline"

    s += r"\end{tabular}"

    return s

  Matriu_com_a_Taula(D,6,6)
#+end_src

#+RESULTS:
#+begin_export latex
\begin{tabular}{|c|c|c|}\hline$i$ & $j$ & $D_{i,j}$ \\ \hline $ 1 $ & $ 1 $ & $ 0 $\\ \hline $ 1 $ & $ 2 $ & $ 0 $\\ \hline $ 1 $ & $ 3 $ & $ 0 $\\ \hline $ 1 $ & $ 4 $ & $ \frac{\frac{3 \phi^{BN}_{1r}}{4} + \phi^{BN}_{1ti} e^{i \left(- \frac{a q_{x}}{2} + \frac{\sqrt{3} a q_{y}}{2}\right)} + \frac{\phi^{BN}_{1ti}}{4} + \left(\frac{3 \phi^{BN}_{1r}}{4} + \frac{\phi^{BN}_{1ti}}{4}\right) e^{- i a q_{x}}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 1 $ & $ 5 $ & $ \frac{- \frac{\sqrt{3} \phi^{BN}_{1r}}{4} + \frac{\sqrt{3} \phi^{BN}_{1ti}}{4} + \left(\frac{\sqrt{3} \phi^{BN}_{1r}}{4} - \frac{\sqrt{3} \phi^{BN}_{1ti}}{4}\right) e^{- i a q_{x}}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 1 $ & $ 6 $ & $ 0 $\\ \hline $ 2 $ & $ 1 $ & $ 0 $\\ \hline $ 2 $ & $ 2 $ & $ 0 $\\ \hline $ 2 $ & $ 3 $ & $ 0 $\\ \hline $ 2 $ & $ 4 $ & $ \frac{- \frac{\sqrt{3} \phi^{BN}_{1r}}{4} + \frac{\sqrt{3} \phi^{BN}_{1ti}}{4} + \left(\frac{\sqrt{3} \phi^{BN}_{1r}}{4} - \frac{\sqrt{3} \phi^{BN}_{1ti}}{4}\right) e^{- i a q_{x}}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 2 $ & $ 5 $ & $ \frac{\phi^{BN}_{1r} e^{i \left(- \frac{a q_{x}}{2} + \frac{\sqrt{3} a q_{y}}{2}\right)} + \frac{\phi^{BN}_{1r}}{4} + \frac{3 \phi^{BN}_{1ti}}{4} + \left(\frac{\phi^{BN}_{1r}}{4} + \frac{3 \phi^{BN}_{1ti}}{4}\right) e^{- i a q_{x}}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 2 $ & $ 6 $ & $ 0 $\\ \hline $ 3 $ & $ 1 $ & $ 0 $\\ \hline $ 3 $ & $ 2 $ & $ 0 $\\ \hline $ 3 $ & $ 3 $ & $ 0 $\\ \hline $ 3 $ & $ 4 $ & $ 0 $\\ \hline $ 3 $ & $ 5 $ & $ 0 $\\ \hline $ 3 $ & $ 6 $ & $ \frac{\phi^{BN}_{1to} e^{i \left(- \frac{a q_{x}}{2} + \frac{\sqrt{3} a q_{y}}{2}\right)} + \phi^{BN}_{1to} + \phi^{BN}_{1to} e^{- i a q_{x}}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 4 $ & $ 1 $ & $ \frac{\frac{3 \phi^{BN}_{1r}}{4} + \phi^{BN}_{1ti} e^{i \left(\frac{a q_{x}}{2} - \frac{\sqrt{3} a q_{y}}{2}\right)} + \frac{\phi^{BN}_{1ti}}{4} + \left(\frac{3 \phi^{BN}_{1r}}{4} + \frac{\phi^{BN}_{1ti}}{4}\right) e^{i a q_{x}}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 4 $ & $ 2 $ & $ \frac{- \frac{\sqrt{3} \phi^{BN}_{1r}}{4} + \frac{\sqrt{3} \phi^{BN}_{1ti}}{4} + \left(\frac{\sqrt{3} \phi^{BN}_{1r}}{4} - \frac{\sqrt{3} \phi^{BN}_{1ti}}{4}\right) e^{i a q_{x}}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 4 $ & $ 3 $ & $ 0 $\\ \hline $ 4 $ & $ 4 $ & $ 0 $\\ \hline $ 4 $ & $ 5 $ & $ 0 $\\ \hline $ 4 $ & $ 6 $ & $ 0 $\\ \hline $ 5 $ & $ 1 $ & $ \frac{- \frac{\sqrt{3} \phi^{BN}_{1r}}{4} + \frac{\sqrt{3} \phi^{BN}_{1ti}}{4} + \left(\frac{\sqrt{3} \phi^{BN}_{1r}}{4} - \frac{\sqrt{3} \phi^{BN}_{1ti}}{4}\right) e^{i a q_{x}}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 5 $ & $ 2 $ & $ \frac{\phi^{BN}_{1r} e^{i \left(\frac{a q_{x}}{2} - \frac{\sqrt{3} a q_{y}}{2}\right)} + \frac{\phi^{BN}_{1r}}{4} + \frac{3 \phi^{BN}_{1ti}}{4} + \left(\frac{\phi^{BN}_{1r}}{4} + \frac{3 \phi^{BN}_{1ti}}{4}\right) e^{i a q_{x}}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 5 $ & $ 3 $ & $ 0 $\\ \hline $ 5 $ & $ 4 $ & $ 0 $\\ \hline $ 5 $ & $ 5 $ & $ 0 $\\ \hline $ 5 $ & $ 6 $ & $ 0 $\\ \hline $ 6 $ & $ 1 $ & $ 0 $\\ \hline $ 6 $ & $ 2 $ & $ 0 $\\ \hline $ 6 $ & $ 3 $ & $ \frac{\phi^{BN}_{1to} e^{i \left(\frac{a q_{x}}{2} - \frac{\sqrt{3} a q_{y}}{2}\right)} + \phi^{BN}_{1to} e^{i a q_{x}} + \phi^{BN}_{1to}}{\sqrt{M_{B} M_{N}}} $\\ \hline $ 6 $ & $ 4 $ & $ 0 $\\ \hline $ 6 $ & $ 5 $ & $ 0 $\\ \hline $ 6 $ & $ 6 $ & $ 0 $\\ \hline\end{tabular}
#+end_export


\newpage
\eject \pdfpagewidth=480mm \pdfpageheight=297mm
*** Ajuste a los datos experimentales
Podemos evaluar la matriz dinámica en el punto $\Gamma$ ($q_x=0,q_y=0$).

#+begin_src python :session :results latex :exports both
  from periodictable import B, N, constants
  u=constants.atomic_mass_constant
  D_Gamma=D.subs([(q_x,0),(q_y,0)]) #,(M_B,B.mass*u),(M_N,N.mass*u)])
  latex(Matrix([D_Gamma[i,j].factor() for i in range(6) for j in range(6)]).reshape(6,6))
#+end_src

#+RESULTS:
#+begin_export latex
\left[\begin{matrix}0 & 0 & 0 & \frac{3 \left(\phi^{BN}_{1r} + \phi^{BN}_{1ti}\right)}{2 \sqrt{M_{B} M_{N}}} & 0 & 0\\0 & 0 & 0 & 0 & \frac{3 \left(\phi^{BN}_{1r} + \phi^{BN}_{1ti}\right)}{2 \sqrt{M_{B} M_{N}}} & 0\\0 & 0 & 0 & 0 & 0 & \frac{3 \phi^{BN}_{1to}}{\sqrt{M_{B} M_{N}}}\\\frac{3 \left(\phi^{BN}_{1r} + \phi^{BN}_{1ti}\right)}{2 \sqrt{M_{B} M_{N}}} & 0 & 0 & 0 & 0 & 0\\0 & \frac{3 \left(\phi^{BN}_{1r} + \phi^{BN}_{1ti}\right)}{2 \sqrt{M_{B} M_{N}}} & 0 & 0 & 0 & 0\\0 & 0 & \frac{3 \phi^{BN}_{1to}}{\sqrt{M_{B} M_{N}}} & 0 & 0 & 0\end{matrix}\right]
#+end_export

Deebemos determinar las constantes de fuerza sabiendo que demeos obtener $830 cm^{-1}$ para el fonon fuera de plano, $1395 cm^{-1}$ para los dos degenerados en el plano, y $0$ 3 veces.
#+begin_src python :session :results latex :exports both
  #D_Gamma=D.subs([(q_x,0),(q_y,0),(M_B,B.mass*u),(M_N,N.mass*u)])
  P_Gamma,D_Gamma_diagonalitzada=D_Gamma.diagonalize()
  latex(D_Gamma_diagonalitzada)
#+end_src

#+RESULTS:
#+begin_export latex
\left[\begin{matrix}- 3 \phi^{BN}_{1to} \sqrt{\frac{1}{M_{B} M_{N}}} & 0 & 0 & 0 & 0 & 0\\0 & 3 \phi^{BN}_{1to} \sqrt{\frac{1}{M_{B} M_{N}}} & 0 & 0 & 0 & 0\\0 & 0 & - \frac{3 \sqrt{\frac{1}{M_{B} M_{N}}} \left(\phi^{BN}_{1r} + \phi^{BN}_{1ti}\right)}{2} & 0 & 0 & 0\\0 & 0 & 0 & - \frac{3 \sqrt{\frac{1}{M_{B} M_{N}}} \left(\phi^{BN}_{1r} + \phi^{BN}_{1ti}\right)}{2} & 0 & 0\\0 & 0 & 0 & 0 & \frac{3 \sqrt{\frac{1}{M_{B} M_{N}}} \left(\phi^{BN}_{1r} + \phi^{BN}_{1ti}\right)}{2} & 0\\0 & 0 & 0 & 0 & 0 & \frac{3 \sqrt{\frac{1}{M_{B} M_{N}}} \left(\phi^{BN}_{1r} + \phi^{BN}_{1ti}\right)}{2}\end{matrix}\right]
#+end_export

De manera que los valores propios que obtenemos son:
#+begin_src python :session :results latex :exports both
  def Valors_propis(Matriu,n):
    P,valors=Matriu.diagonalize()
    s = r"\begin{tabular}{|c|c|}\hline"
    s += r"$i$ & $\omega^{2}$ \\ \hline"
    for i in range(n):
      s += " $ %d $ & $ %s $" %(i, valors[i,i] )
    
    s += r"\end{tabular}"

    return s

#+end_src

#+RESULTS:
#+begin_export latex
#+end_export

#+end_export

\newpage

\printbibliography

# bibliography:TFG-Casimir.bib
vec
